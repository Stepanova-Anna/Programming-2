# Лабораторная работа № 6. Задачи.
**1:** Анализ мест в коде с исключительными ситуациями. Исключительная ситуация может возникнуть на этапе работы с файлом (чтение, запись). Программа может не считать файл с настройками например, из-за ограниченного набора прав пользователя, запустившего данную программу или каких-либо настроек других ОС. Эти ситуации мы можем обработать с помощью блока (см. рабочий пример в стартовом борде):
```
try
    pass # какое-то выражение, возможно, поднимающее исключение  
except Exception:
   print('Исключение возникло') # обработка исключения 
else:
   # блок, выполняющийся, если исключения не было
finally:
   # блок, который выполняется в всегда независимо от того, было ли исключение или нет
```

**Результат:**

![Лабораторная работа 6. Задание 1](https://github.com/Stepanova-Anna/Programming-2/blob/main/img/LR6_T1.png)

Конструктор ```__init__``` принимает два параметра: ```count``` (количество случайных чисел) и ```range_tuple``` (кортеж с минимальным и максимальным значениями диапазона).
Метод ```__iter__``` возвращает сам объект итератора, что позволяет использовать его в цикле ```for```
Метод ```__next__```
   - Генерирует случайное число в заданном диапазоне с помощью ```random.randint()```
   - Увеличивает счетчик сгенерированных чисел
   - Если количество сгенерированных чисел достигает count, выбрасывает ```StopIteration```, чтобы завершить итерацию

---
**2:** Модульное тестирование с unittest. Шаблон для тестирования с помощью unittest может выглядеть так:
```
import unittest

class TestSomeFunc(unittest.TestCase): # создаем свой класс для тестов

     def firsttestcase(self): # внутри функции один или несколько тестовых
         self.assertEqual(2*2, 4) # случаев, которые проверяют какие-то 
         # близкие предположения
         

     # ...
     def secondtestcase(self): # вторая группа тестов
         pass

unittest.main(verbosity=1)     # запуск тестов
```
Пример тестирования двух функций convert_precision и two_sum, которую мы создавали ранее. Нюанс тестирования в repl.it и PyCharm. В repl.it  тесты запускаются вручную с помощью вкладки Shell (справа) (пример борда), в PyCharm требуется закомментировать запуск тестов с помощью: 
```
unittest.main(verbosity=1)
```
**Результат:**

![Лабораторная работа 5. Задание 3](https://github.com/Stepanova-Anna/Programming-2/blob/main/img/LR5_T3.png)

Ключевое слово ```yield``` используется для возврата сгенерированного числа
```
yield random.randint(self.range_start, self.range_end)
```

---
**3:** Тестирование с помощью pytest. По аналогии с предыдущим пунктом 2. Перепешите те же самые тесты с помощью фреймворка pytest. Сравните его использование с фреймворком unittest.

**Результат:**

Сравнение unittest и pytest
unittest:
   • unittest требует создания классов и методов для тестов, что может быть более громоздким.
   • В unittest для достижения подобного результата нужно использовать дополнительные методы или библиотеки.
   • unittest также поддерживает расширения, но их количество и разнообразие не так велико.
pytest:
   • pytest использует простые функции для тестов, что делает код более читаемым и лаконичным.
   • В pytest сообщения об ошибках более информативные и удобочитаемые. Он предоставляет детальную информацию о том, какие именно проверки не прошли.
   • pytest поддерживает параметризацию тестов, что позволяет запускать один и тот же тест с различными наборами данных без необходимости дублировать код.
   • pytest имеет множество плагинов и расширений, которые позволяют легко добавлять функциональность (например, для тестирования асинхронного кода или интеграции с другими инструментами).

Оба фреймворка активно поддерживаются и имеют хорошую документацию. Однако pytest стал более популярным в последние годы среди разработчиков Python.

![Лабораторная работа 5. Задание 3](https://github.com/Stepanova-Anna/Programming-2/blob/main/img/LR5_T3.png)
 

---
**1.4:** Напишите программу, на вход к которой подается список стран и городов для каждой страны. Затем по названиям городов из ещё одного
списка выводится в какой стране расположен каждый город

**Результат:**

Словарь ```coun_cit``` содержит названия стран в качестве ключей и списки городов в этих странах в качестве значений. Это позволяет быстро находить все города, относящиеся к конкретной стране.

![Лабораторная работа 5. Задание 4](https://github.com/Stepanova-Anna/Programming-2/blob/main/img/LR5_T4.png)


---
**2.1:** Напишите класс менеджера контекста Timer, который умеет считать
время в секундах, затраченное на некоторые вычисления внутри соответствующего блока with с помощью функции perf_counter модуля time. Используйте этот менеджер контекста для определения времени на вычисления достаточно большого количества чисел Фибоначчи (например миллиона) в цикле с помощью отдельной функциигенератора.

**Результат:**

Программа выведет общее время, затраченное на их генерацию, в секундах при помощи класса ```Timer```, который позволяет измерять время выполнения блока кода с помощью конструкции ```with```


![Лабораторная работа 5. Задание 5](https://github.com/Stepanova-Anna/Programming-2/blob/main/img/LR5_T5.png)


---
**2.2:** Напишите класс менеджера контекста BatchCalculatorContextManager,
для вашего проекта калькулятора из предыдущих лабораторных работ. Этот менеджер контекста должен уметь открывать и закрывать текстовый файл, в каждой строчке которого записана пара чисел в
сочетании с арифметической операцией над ними в виде простого
арифметического выражения без пробелов. В сочетании с дополнительной функцией генератором и вашим менеджером контекста прочитайте все строчки текстового файла и вызовите нужное число раз
функцию calculate(...) вашего калькулятора, чтобы распечатать
все результаты на экране.

**Результат:**
Программа возварщает результаты вычислений примеров, которые написаны в отдельном файле operations.txt 

![Лабораторная работа 5. Задание 6](https://github.com/Stepanova-Anna/Programming-2/blob/main/img/LR5_T6.png)
