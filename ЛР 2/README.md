**1.1:** Создайте простое замыкание (closure) в виде внутренней (вложенной) функции внутри обычной функции. Внутренняя функция (замыкание, closure) должна использовать переменные и аргументы обычной функции, в которую она вложена. Внутри внутренней функции (closure) распечатайте переданные аргументы в терминале. Верните вложенную функцию из обычной функции с помощью выражения return.

**Результат:**
![Лабораторная работа 2. Задание 1](main/img/LR2_T1.png)

Функция foo является внешней функцией, которая создает и возвращает внутреннюю функцию inner_boo. Внутренняя функция возвращает словарь с личными данными.

```
return inner_boo # return inner_boo() без '()' возвращает ссылку на функцию inner_boo, а не вызов функции
print(foo()()) # чтобы вернуть вывод функци inner_boo, нужно вызвать ее с '()'
```
---
**1.2:** Изучите на примерах в интернете, что такое closure и и как их применять для создания простого декоратора (decorator) с @-синтаксисом в Python. Модернизируйте калькулятор из задачи 3.1 лабораторной работы №1. Декорируйте вашу функцию calculate. В соответствующем декорирующем замыкании, в сlosure, то есть во внутренней функции используйте простое логирование (стандартный модуль Python logging). Сделайте логирование внутри замыкания до вызова вашей функции calculate(operand1, operand2, action), в котором логируется информация о том какие операнды и какая арифметическая операция собираются поступить на вход функции calculate(operand1, operand2, action). Затем внутри того же closure следует сам вызов функции calculate(...). А затем, после этого вызова должно быть снова логирование, но уже с результатом выполнения вычисления, проделанного в этой функции.

**Результат:**
![Лабораторная работа 2. Задание 2](img/LR2_T2.png)

Функция логгирования log_decorator принимает на вход другую функцию и возвращает обертку вокруг неё. Внутри обертки происходит логирование входных данных (числа a, b и операнд) с помощью модуля logging, затем вызывается оригинальная функция, и после этого логируется результат вычислений.



---
**1.3:** Изучите основы каррирования. Каррирование в самом простом варианте - это создание специализированной функции на основе более
общей функции с предустановленными параметрами для этой более общей функции. Реализуйте каррирование на примере вычисления количества радиоактивного вещества N, оставшегося в некоторый момент времени t от радокактивного вещества с периодом полураспада t1/2, если изначально это количество было равно N0. Закон распада
задан формулой ... В качестве проставленного заранее параметра в данном примере должно быть значение периода полураспада t1/2, которое постоянно для
каждого типа радиоактивного материала (радиоактивного изотопа химического элемента). Сделайте словарь, где в качестве колючей используются строки с символами радиоактивных изотопов, а в качестве значений им сопоставлены каррированные с характерными периодами полураспада. В основном коде вашей программы организуйте цикл по этому словарю и продемонстрируйте в нём вызовы каррированных функций с распечаткой на экране сколько вещества осталось от одного и того же N0 в некоторый момент времени t в зависимости от типа изотопа.

**Результат:**

---
**1.4:** Напишите unit-тесты для калькулятора из задачи 3.1 лабораторной работы № 1 используя стандартный модуль unittest библиотеки Python.

**Результат:**

Для проведения тестов необходимо было импортировать файлы (находящиеся в одной папке):
```
import unittest
import Calc
import T3
```
